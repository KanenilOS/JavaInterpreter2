package org.interpreter.parser;

import org.interpreter.exceptions.InterpreterRuntimeException;
import org.interpreter.lexer.Command;
import org.interpreter.lexer.Lexer;
import org.interpreter.parser.expressions.*;
import org.interpreter.parser.statements.*;
import org.interpreter.parser.variable.VariableReference;
import org.interpreter.runtime.RuntimeEnvironment;
import org.interpreter.token.Token;
import org.interpreter.token.TokenType;

import java.util.*;

/**
 * Parses tokens generated by the Lexer into executable statements according to the
 * grammar of the interpreted language. This class supports various types of statements
 * and expressions, facilitating complex language features such as loops, conditionals, and variable handling.
 */
public class Parser {
    private final Lexer lexer;
    private final RuntimeEnvironment environment;
    private Token currentToken;

    /**
     * Constructs a Parser with a specified lexer and runtime environment.
     * Initializes the parser and preprocesses any labels for jumps and loops.
     *
     * @param lexer the lexer to parse tokens from
     * @param environment the runtime environment where variables and functions are stored
     */
    public Parser(Lexer lexer, RuntimeEnvironment environment) {
        this.lexer = lexer;
        this.environment = environment;
        this.currentToken = lexer.nextToken();
        preprocessLabels();
    }

    /**
     * Preprocesses all labels in the input script to establish jump points for GOTO and GOSUB statements.
     * This method scans the entire set of tokens from the lexer to find label definitions and registers them
     * in the runtime environment for quick access during execution. This is crucial for implementing efficient
     * control flow in the interpreted language.
     */
    private void preprocessLabels() {
        while(!isType(TokenType.EOF)) {
            if(isType(TokenType.LABEL)) {
                String label = currentToken.text();
                processLabel(label, environment);
            }

            currentToken = lexer.nextToken();
        }

        lexer.reset();
        currentToken = lexer.nextToken();
    }

    /**
     * Processes a specific label by storing the subsequent statements associated with the label
     * until a control flow command like RETURN or END is encountered. This organizes the code
     * for efficient execution when a GOTO or GOSUB command is issued.
     *
     * @param label the label identifier from the source code
     * @param environment the runtime environment where the label and associated statements are registered
     */
    private void processLabel(String label, RuntimeEnvironment environment) {
        List<Statement> statementList = new ArrayList<>();

        currentToken = lexer.nextToken();

        while (!isEndOfFile() && !(isType(TokenType.COMMAND) && isValueOnTheList(getCommandFromCurrentToken(), List.of(Command.RETURN, Command.END)))) {
            Statement statement = parseStatement();
            statementList.add(statement);
        }

        environment.registerLabel(label, statementList);
    }

    /**
     * Parses tokens from the lexer into a list of executable statements. This method serves as the primary
     * entry point for converting raw tokens into structured code that can be executed by the runtime environment.
     *
     * @return a list of parsed statements, ready for execution.
     */
    public List<Statement> parse() {
        List<Statement> statements = new ArrayList<>();
        while (!isType(TokenType.EOF)) {
            Statement statement = parseStatement();
            if (statement != null) {
                statements.add(statement);
            }

            if(isType(TokenType.SEMICOLON))
                currentToken = lexer.nextToken();
        }
        return statements;
    }

    /**
     * Parses the current token into a Statement object. The type of statement is determined by the
     * type of the current token and could be one of several different statement types like
     * assignment, control flow, etc.
     *
     * @return the parsed statement, or null if a placeholder or unrecognized token is encountered.
     */
    private Statement parseStatement() {
        return switch (currentToken.type()) {
            case COMMAND -> parseCommand();
            case VARIABLE -> parseAssignment();
            case LABEL -> {
                while (!isCommand(Command.RETURN)) {
                    currentToken = lexer.nextToken();
                }
                currentToken = lexer.nextToken();
                yield null;
            }
            default -> throw new RuntimeException("Syntax Error: Unexpected token '" + currentToken.text() + "'");
        };
    }

    /**
     * Parses a command token into a Statement. Commands include PRINT, IF, FOR, etc.
     * The specific parsing logic depends on the type of command.
     *
     * @return the parsed command as a Statement
     */
    private Statement parseCommand() {
        Command command = Objects.requireNonNull(getCommandFromCurrentToken());
        return switch (command) {
            case PRINT -> parsePrintStatement();
            case IF -> parseIfStatement();
            case FOR -> parseForStatement();
            case INPUT -> parseInputStatement();
            case GOTO -> parseGotoStatement();
            case GOSUB -> parseGosubStatement();
            default -> throw new InterpreterRuntimeException(String.format("Command not supported '%s' at line %s", command, currentToken.lineNumber()));
        };
    }

    /**
     * Parses a PRINT command into a PrintStatement. The PRINT command can include various expressions
     * which need to be evaluated and printed.
     *
     * @return a new PrintStatement constructed with the parsed elements
     */
    private PrintStatement parsePrintStatement() {
        List<Object> elements = new ArrayList<>();
        currentToken = lexer.nextToken();

        while (isParseable() &&
                !isType(TokenType.LABEL) &&
                !isValueOnTheList(getCommandFromCurrentToken(), List.of(Command.INPUT, Command.FOR, Command.GOTO, Command.GOSUB, Command.RETURN, Command.PRINT, Command.END))
        ) {
            elements.add(parseExpression());

            if (isValueOnTheList(currentToken.type(), List.of(TokenType.COMMA, TokenType.SEMICOLON))) {
                currentToken = lexer.nextToken();
            }
        }

        return new PrintStatement(elements);
    }

    /**
     * Parses an IF command into an IfStatement. This involves parsing a condition expression and
     * then parsing the true and optionally the false branches.
     *
     * @return the newly constructed IfStatement
     */
    private Statement parseIfStatement() {
        expect(getCommandFromCurrentToken(), Command.IF, String.valueOf(currentToken.lineNumber()));
        currentToken = lexer.nextToken();
        Expression condition = parseExpression();

        expect(getCommandFromCurrentToken(), Command.THEN, String.valueOf(currentToken.lineNumber()));
        currentToken = lexer.nextToken();

        List<Statement> trueBranch = new ArrayList<>();
        List<Statement> falseBranch = null;

        while (!isValueOnTheList(getCommandFromCurrentToken(), List.of(Command.ENDIF, Command.ELSE))) {
            trueBranch.add(parseStatement());
        }

        if (isCommand(Command.ELSE)) {
            currentToken = lexer.nextToken();
            falseBranch = new ArrayList<>();
            while (!isCommand(Command.ENDIF)) {
                falseBranch.add(parseStatement());
            }
        }

        expect(getCommandFromCurrentToken(), Command.ENDIF, String.valueOf(currentToken.lineNumber()));
        currentToken = lexer.nextToken();

        return new IfStatement(condition, trueBranch, falseBranch);
    }

    /**
     * Parses a FOR command into a ForStatement. This involves reading the loop control variable,
     * the start and end expressions, and the body of the loop.
     *
     * @return a new ForStatement representing the parsed FOR loop
     */
    private Statement parseForStatement() {
        currentToken = lexer.nextToken();
        expect(currentToken.type(), TokenType.VARIABLE, String.valueOf(currentToken.lineNumber()));

        String variableName = currentToken.text();
        currentToken = lexer.nextToken();

        expect(currentToken.type(), TokenType.EQUAL, String.valueOf(currentToken.lineNumber()));
        currentToken = lexer.nextToken();

        Expression startExpression = parseExpression();

        expect(currentToken.type(), Command.TO, String.valueOf(currentToken.lineNumber()));
        currentToken = lexer.nextToken();

        Expression endExpression = parseExpression();

        List<Statement> body = new ArrayList<>();
        while (!isCommand(Command.NEXT) && !isType(TokenType.EOF)) {
            body.add(parseStatement());
        }
        currentToken = lexer.nextToken();

        return new ForStatement(variableName, startExpression, endExpression, body);
    }

    /**
     * Parses an INPUT command into an InputStatement, which includes a prompt (if provided)
     * and the name of the variable where the user's input will be stored.
     *
     * @return a new InputStatement constructed from the parsed components
     */
    private Statement parseInputStatement() {
        currentToken = lexer.nextToken();
        String prompt = null;

        if(isType(TokenType.QUOTEDSTR)) {
            prompt = currentToken.text();
            currentToken = lexer.nextToken();

            expect(currentToken.type(), TokenType.COMMA, String.valueOf(currentToken.lineNumber()));
            currentToken = lexer.nextToken();
        }

        expect(currentToken.type(), TokenType.VARIABLE, String.valueOf(currentToken.lineNumber()));
        String variableName = currentToken.text();
        currentToken = lexer.nextToken();

        return new InputStatement(prompt, variableName);
    }

    /**
     * Parses a GOTO command into a GoToStatement, which identifies a label to jump to within
     * the script.
     *
     * @return a new GoToStatement that represents the jump to a label
     */
    private Statement parseGotoStatement() {
        currentToken = lexer.nextToken();

        expect(currentToken.type(), TokenType.VARIABLE, String.valueOf(currentToken.lineNumber()), "DIMENSION");
        String label = currentToken.text();

        while (!(isType(TokenType.EOF) || isCommand(Command.END))) {
            currentToken = lexer.nextToken();
        }

        return new GoToStatement(label);
    }

    /**
     * Parses a GOSUB command similar to GOTO but intended for subroutines. The GOSUB
     * statement will jump to a label and expects a RETURN statement to return control to the
     * calling location.
     *
     * @return a new GoToStatement, which acts as a subroutine call by jumping to a label
     */
    private Statement parseGosubStatement() {
        currentToken = lexer.nextToken();

        expect(currentToken.type(), TokenType.VARIABLE, String.valueOf(currentToken.lineNumber()), "DIMENSION");
        String label = currentToken.text();

        currentToken = lexer.nextToken();

        return new GoToStatement(label);
    }

    /**
     * Parses expressions, which can include arithmetic operations, variable references, or literal values.
     * This is a generic method that delegates to more specific methods depending on the complexity of the expression.
     *
     * @return an Expression object representing the parsed expression
     */
    private Expression parseExpression() {
        Expression result = parseAdditionSubtraction();

        while (isRelationalOperator(currentToken)) {
            TokenType operatorType = currentToken.type();
            currentToken = lexer.nextToken();
            Expression right = parseAdditionSubtraction();

            if (operatorType == TokenType.EQUAL) {
                result = new EqualityExpression(result, right);
            } else {
                result = new RelationalExpression(result, operatorType, right);
            }
        }

        return result;
    }

    /**
     * Parses addition and subtraction operations, which are binary operations involving two operands.
     *
     * @return an Expression object representing either an addition or subtraction
     */
    private Expression parseAdditionSubtraction() {
        Expression result = parseMultiplicationDivision();

        while (isValueOnTheList(currentToken.type(), List.of(TokenType.PLUS, TokenType.MINUS))) {
            TokenType type = currentToken.type();

            currentToken = lexer.nextToken();
            Expression right = parseMultiplicationDivision();

            result = isType(type, TokenType.PLUS) ?
                    new AdditionExpression(result, right) :
                    new SubtractionExpression(result, right);
        }

        return result;
    }

    /**
     * Parses multiplication, division, and modulus operations. Handles the precedence of these
     * operations within expressions.
     *
     * @return an Expression object representing either a multiplication, division, or modulus operation
     */
    private Expression parseMultiplicationDivision() {
        Expression result = parseFactor();

        while (isValueOnTheList(currentToken.type(), List.of(TokenType.MULTIPLY, TokenType.DIVISION, TokenType.MODULUS))) {
            TokenType type = currentToken.type();

            currentToken = lexer.nextToken();
            Expression right = parseFactor();

            result = switch (type) {
                case MULTIPLY -> new MultiplicationExpression(result, right);
                case DIVISION -> new DivisionExpression(result, right);
                case MODULUS -> new ModulusExpression(result, right);
                default -> null;
            };
        }

        return result;
    }

    /**
     * Parses the smallest unit of an expression, which could be a numeric literal, a variable reference,
     * or a more complex expression enclosed in parentheses.
     *
     * @return an Expression object representing the parsed factor
     */
    private Expression parseFactor() {
        TokenType type = currentToken.type();

        String value = currentToken.text();
        currentToken = lexer.nextToken();

        return switch (type) {
            case QUOTEDSTR -> new StringExpression(value);
            case VARIABLE -> new VariableReference(value);
            case NUMBER -> new NumericExpression(Double.parseDouble(value));
            case OPEN_PAREN -> {
                Expression expression = parseExpression();
                if (!isType(TokenType.CLOSE_PAREN)) {
                    throw new InterpreterRuntimeException(String.format("Missing closing parenthesis. At line %s", currentToken.lineNumber()));
                }
                currentToken = lexer.nextToken();
                yield expression;
            }
            default -> throw new InterpreterRuntimeException(String.format("Unexpected token: %s at line %s", type, currentToken.lineNumber()));
        };
    }

    /**
     * Parses an assignment statement. It expects to find a variable followed by an '=' operator
     * and an expression that provides the value to be assigned to the variable.
     *
     * @return an AssignmentStatement that encapsulates the variable name and the expression
     *         to be assigned to it.
     */
    private Statement parseAssignment() {
        String variableName = currentToken.text();
        currentToken = lexer.nextToken();
        expect(currentToken.type(), TokenType.EQUAL, String.valueOf(currentToken.lineNumber()));

        currentToken = lexer.nextToken();
        Expression value = parseExpression();

        return new AssignmentStatement(variableName, value);
    }

    /**
     * Checks if the current token type allows continuation of parsing for statements or expressions.
     * This method is primarily used to determine if parsing should proceed or if there are delimiters like
     * EOF, EOL, or SEMICOLON that indicate the end of a statement or expression.
     *
     * @return true if the current token is not a stopping point for parsing.
     */
    private boolean isParseable() {
        return !(isValueOnTheList(currentToken.type(), List.of(TokenType.EOF, TokenType.EOL, TokenType.SEMICOLON)) ||
                isValueOnTheList(getCommandFromCurrentToken(), List.of(Command.NEXT, Command.ENDIF, Command.ELSE)));
    }

    /**
     * Retrieves the Command associated with the current token if it represents a command.
     *
     * @return the Command corresponding to the current token or null if the token is not a command.
     */
    private Command getCommandFromCurrentToken() {
        return isType(TokenType.COMMAND) ? Command.fromString(currentToken.text()) : null;
    }

    /**
     * Determines if a given value is on a specified list. This method is commonly used to check if
     * a token type or command matches any in a list of expected types or commands.
     *
     * @param value the value to check against the list.
     * @param list the list of values to be checked against.
     * @return true if the value is found in the list; otherwise, false.
     */
    private boolean isValueOnTheList(Object value, List<Object> list) {
        return value != null && list.contains(value);
    }

    /**
     * Determines if the current token matches the specified token type.
     *
     * @param tokenType the TokenType to check against the current token
     * @return true if the current token type matches the specified token type
     */
    private boolean isType(TokenType tokenType) {
        return currentToken.type() == tokenType;
    }

    /**
     * Compares two TokenType values to determine if they are equal.
     *
     * @param actualValue the TokenType to check.
     * @param expectedValue the TokenType expected.
     * @return true if both TokenType values are the same; otherwise, false.
     */
    private boolean isType(TokenType actualValue, TokenType expectedValue) {
        return actualValue == expectedValue;
    }

    /**
     * Checks if the current token's command matches the specified command.
     *
     * @param command the command to compare against the current token's command.
     * @return true if the current token's command is the same as the specified command; otherwise, false.
     */
    private boolean isCommand(Command command) {
        return getCommandFromCurrentToken() == command;
    }

    /**
     * Overload of isCommand specifically to compare two commands for equality.
     *
     * @param actualValue the command to be checked.
     * @param expectedValue the command expected.
     * @return true if both commands are the same; otherwise, false.
     */
    private boolean isCommand(Command actualValue, Command expectedValue) {
        return actualValue == expectedValue;
    }

    /**
     * Checks if the end of the file has been reached based on the current token.
     *
     * @return true if the current token's type is EOF; otherwise, false.
     */
    private boolean isEndOfFile() {
        return currentToken.type() == TokenType.EOF;
    }

    /**
     * Ensures that the current token matches an expected type or command, throwing an exception if not.
     *
     * @param actualValue the actual value to check
     * @param expectedValue the expected value to match
     * @param optionalMessage additional message information, such as line number or custom error messages
     */
    private void expect(Object actualValue, Object expectedValue, String... optionalMessage) {
        boolean isCommand = actualValue instanceof Command &&
                expectedValue instanceof Command &&
                !isCommand((Command) actualValue, (Command) expectedValue);

        boolean isType = actualValue instanceof TokenType &&
                expectedValue instanceof TokenType &&
                !isType((TokenType) actualValue, (TokenType) expectedValue);

        String message = optionalMessage.length == 2 ? optionalMessage[1] : expectedValue.toString();
        String line = optionalMessage.length > 0 ? optionalMessage[0] : "none";

        if (isCommand || isType) {
            throw new InterpreterRuntimeException(String.format("Expected '%s' but found '%s' at line %s", message, actualValue, line));
        }
    }

    /**
     * Determines if the current token is a relational operator, which is used in parsing expressions
     * that compare values (e.g., less than, greater than).
     *
     * @param token the token to check if it's a relational operator.
     * @return true if the token is a relational operator; otherwise, false.
     */
    private boolean isRelationalOperator(Token token) {
        return switch (token.type()) {
            case LESS_THAN, GREATER_THAN, LESS_EQUAL, GREATER_EQUAL, EQUAL, NOT_EQUAL -> true;
            default -> false;
        };
    }
}
